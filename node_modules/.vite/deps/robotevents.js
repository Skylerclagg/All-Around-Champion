import {
  require_authentication,
  require_ratelimit,
  require_request,
  require_skills
} from "./chunk-CLCNREFW.js";
import {
  __commonJS
} from "./chunk-DFKQJ226.js";

// node_modules/robotevents/out/endpoints/programs/index.js
var require_programs = __commonJS({
  "node_modules/robotevents/out/endpoints/programs/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.get = exports.all = exports.fetch = void 0;
    var request_1 = __importStar(require_request());
    async function fetch(id, maxAge) {
      return (0, request_1.requestSingle)(`programs/${id}`, {}, maxAge);
    }
    exports.fetch = fetch;
    async function all(maxAge) {
      return (0, request_1.default)("programs", {}, maxAge);
    }
    exports.all = all;
    var programs = {
      V5RC: 1,
      VURC: 4,
      WORKSHOP: 37,
      VIQRC: 41,
      NRL: 43,
      ADC: 44,
      TVRC: 46,
      TVIQRC: 47,
      VRAD: 51,
      BellAVR: 55,
      FAC: 56,
      VAIRC: 57
    };
    function get(abbr) {
      var _a;
      return (_a = programs[abbr]) !== null && _a !== void 0 ? _a : 0;
    }
    exports.get = get;
  }
});

// node_modules/robotevents/out/endpoints/events/search.js
var require_search = __commonJS({
  "node_modules/robotevents/out/endpoints/events/search.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    var request_1 = __importDefault(require_request());
    var _1 = require_events2();
    async function search(options, maxAge) {
      const results = await (0, request_1.default)("events", options, maxAge);
      return results.map((data) => new _1.Event(data));
    }
    exports.default = search;
  }
});

// node_modules/events/events.js
var require_events = __commonJS({
  "node_modules/events/events.js"(exports, module) {
    "use strict";
    var R = typeof Reflect === "object" ? Reflect : null;
    var ReflectApply = R && typeof R.apply === "function" ? R.apply : function ReflectApply2(target, receiver, args) {
      return Function.prototype.apply.call(target, receiver, args);
    };
    var ReflectOwnKeys;
    if (R && typeof R.ownKeys === "function") {
      ReflectOwnKeys = R.ownKeys;
    } else if (Object.getOwnPropertySymbols) {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
      };
    } else {
      ReflectOwnKeys = function ReflectOwnKeys2(target) {
        return Object.getOwnPropertyNames(target);
      };
    }
    function ProcessEmitWarning(warning) {
      if (console && console.warn)
        console.warn(warning);
    }
    var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
      return value !== value;
    };
    function EventEmitter() {
      EventEmitter.init.call(this);
    }
    module.exports = EventEmitter;
    module.exports.once = once;
    EventEmitter.EventEmitter = EventEmitter;
    EventEmitter.prototype._events = void 0;
    EventEmitter.prototype._eventsCount = 0;
    EventEmitter.prototype._maxListeners = void 0;
    var defaultMaxListeners = 10;
    function checkListener(listener) {
      if (typeof listener !== "function") {
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
      }
    }
    Object.defineProperty(EventEmitter, "defaultMaxListeners", {
      enumerable: true,
      get: function() {
        return defaultMaxListeners;
      },
      set: function(arg) {
        if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
          throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
        }
        defaultMaxListeners = arg;
      }
    });
    EventEmitter.init = function() {
      if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
      }
      this._maxListeners = this._maxListeners || void 0;
    };
    EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
      if (typeof n !== "number" || n < 0 || NumberIsNaN(n)) {
        throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + ".");
      }
      this._maxListeners = n;
      return this;
    };
    function _getMaxListeners(that) {
      if (that._maxListeners === void 0)
        return EventEmitter.defaultMaxListeners;
      return that._maxListeners;
    }
    EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
      return _getMaxListeners(this);
    };
    EventEmitter.prototype.emit = function emit(type) {
      var args = [];
      for (var i = 1; i < arguments.length; i++)
        args.push(arguments[i]);
      var doError = type === "error";
      var events = this._events;
      if (events !== void 0)
        doError = doError && events.error === void 0;
      else if (!doError)
        return false;
      if (doError) {
        var er;
        if (args.length > 0)
          er = args[0];
        if (er instanceof Error) {
          throw er;
        }
        var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
        err.context = er;
        throw err;
      }
      var handler = events[type];
      if (handler === void 0)
        return false;
      if (typeof handler === "function") {
        ReflectApply(handler, this, args);
      } else {
        var len = handler.length;
        var listeners = arrayClone(handler, len);
        for (var i = 0; i < len; ++i)
          ReflectApply(listeners[i], this, args);
      }
      return true;
    };
    function _addListener(target, type, listener, prepend) {
      var m;
      var events;
      var existing;
      checkListener(listener);
      events = target._events;
      if (events === void 0) {
        events = target._events = /* @__PURE__ */ Object.create(null);
        target._eventsCount = 0;
      } else {
        if (events.newListener !== void 0) {
          target.emit(
            "newListener",
            type,
            listener.listener ? listener.listener : listener
          );
          events = target._events;
        }
        existing = events[type];
      }
      if (existing === void 0) {
        existing = events[type] = listener;
        ++target._eventsCount;
      } else {
        if (typeof existing === "function") {
          existing = events[type] = prepend ? [listener, existing] : [existing, listener];
        } else if (prepend) {
          existing.unshift(listener);
        } else {
          existing.push(listener);
        }
        m = _getMaxListeners(target);
        if (m > 0 && existing.length > m && !existing.warned) {
          existing.warned = true;
          var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
          w.name = "MaxListenersExceededWarning";
          w.emitter = target;
          w.type = type;
          w.count = existing.length;
          ProcessEmitWarning(w);
        }
      }
      return target;
    }
    EventEmitter.prototype.addListener = function addListener(type, listener) {
      return _addListener(this, type, listener, false);
    };
    EventEmitter.prototype.on = EventEmitter.prototype.addListener;
    EventEmitter.prototype.prependListener = function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };
    function onceWrapper() {
      if (!this.fired) {
        this.target.removeListener(this.type, this.wrapFn);
        this.fired = true;
        if (arguments.length === 0)
          return this.listener.call(this.target);
        return this.listener.apply(this.target, arguments);
      }
    }
    function _onceWrap(target, type, listener) {
      var state = { fired: false, wrapFn: void 0, target, type, listener };
      var wrapped = onceWrapper.bind(state);
      wrapped.listener = listener;
      state.wrapFn = wrapped;
      return wrapped;
    }
    EventEmitter.prototype.once = function once2(type, listener) {
      checkListener(listener);
      this.on(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };
    EventEmitter.prototype.removeListener = function removeListener(type, listener) {
      var list, events, position, i, originalListener;
      checkListener(listener);
      events = this._events;
      if (events === void 0)
        return this;
      list = events[type];
      if (list === void 0)
        return this;
      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = /* @__PURE__ */ Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit("removeListener", type, list.listener || listener);
        }
      } else if (typeof list !== "function") {
        position = -1;
        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }
        if (position < 0)
          return this;
        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }
        if (list.length === 1)
          events[type] = list[0];
        if (events.removeListener !== void 0)
          this.emit("removeListener", type, originalListener || listener);
      }
      return this;
    };
    EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
    EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
      var listeners, events, i;
      events = this._events;
      if (events === void 0)
        return this;
      if (events.removeListener === void 0) {
        if (arguments.length === 0) {
          this._events = /* @__PURE__ */ Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== void 0) {
          if (--this._eventsCount === 0)
            this._events = /* @__PURE__ */ Object.create(null);
          else
            delete events[type];
        }
        return this;
      }
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === "removeListener")
            continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners("removeListener");
        this._events = /* @__PURE__ */ Object.create(null);
        this._eventsCount = 0;
        return this;
      }
      listeners = events[type];
      if (typeof listeners === "function") {
        this.removeListener(type, listeners);
      } else if (listeners !== void 0) {
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }
      return this;
    };
    function _listeners(target, type, unwrap) {
      var events = target._events;
      if (events === void 0)
        return [];
      var evlistener = events[type];
      if (evlistener === void 0)
        return [];
      if (typeof evlistener === "function")
        return unwrap ? [evlistener.listener || evlistener] : [evlistener];
      return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
    }
    EventEmitter.prototype.listeners = function listeners(type) {
      return _listeners(this, type, true);
    };
    EventEmitter.prototype.rawListeners = function rawListeners(type) {
      return _listeners(this, type, false);
    };
    EventEmitter.listenerCount = function(emitter, type) {
      if (typeof emitter.listenerCount === "function") {
        return emitter.listenerCount(type);
      } else {
        return listenerCount.call(emitter, type);
      }
    };
    EventEmitter.prototype.listenerCount = listenerCount;
    function listenerCount(type) {
      var events = this._events;
      if (events !== void 0) {
        var evlistener = events[type];
        if (typeof evlistener === "function") {
          return 1;
        } else if (evlistener !== void 0) {
          return evlistener.length;
        }
      }
      return 0;
    }
    EventEmitter.prototype.eventNames = function eventNames() {
      return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
    };
    function arrayClone(arr, n) {
      var copy = new Array(n);
      for (var i = 0; i < n; ++i)
        copy[i] = arr[i];
      return copy;
    }
    function spliceOne(list, index) {
      for (; index + 1 < list.length; index++)
        list[index] = list[index + 1];
      list.pop();
    }
    function unwrapListeners(arr) {
      var ret = new Array(arr.length);
      for (var i = 0; i < ret.length; ++i) {
        ret[i] = arr[i].listener || arr[i];
      }
      return ret;
    }
    function once(emitter, name) {
      return new Promise(function(resolve, reject) {
        function errorListener(err) {
          emitter.removeListener(name, resolver);
          reject(err);
        }
        function resolver() {
          if (typeof emitter.removeListener === "function") {
            emitter.removeListener("error", errorListener);
          }
          resolve([].slice.call(arguments));
        }
        ;
        eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
        if (name !== "error") {
          addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
        }
      });
    }
    function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
      if (typeof emitter.on === "function") {
        eventTargetAgnosticAddListener(emitter, "error", handler, flags);
      }
    }
    function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
      if (typeof emitter.on === "function") {
        if (flags.once) {
          emitter.once(name, listener);
        } else {
          emitter.on(name, listener);
        }
      } else if (typeof emitter.addEventListener === "function") {
        emitter.addEventListener(name, function wrapListener(arg) {
          if (flags.once) {
            emitter.removeEventListener(name, wrapListener);
          }
          listener(arg);
        });
      } else {
        throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
      }
    }
  }
});

// node_modules/robotevents/out/WatchableCollection.js
var require_WatchableCollection = __commonJS({
  "node_modules/robotevents/out/WatchableCollection.js"(exports) {
    "use strict";
    var _a;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.deepEquals = void 0;
    var events_1 = require_events();
    var WatchableCollection = class extends events_1.EventEmitter {
      constructor(initial, check) {
        super();
        this.contents = /* @__PURE__ */ new Map();
        this.interval = null;
        this.frequency = 30 * 1e3;
        this.polling = false;
        this[_a] = this.values;
        this.contents = new Map(initial);
        this.check = check;
      }
      // Map methods
      /**
       * Empties the contents of the collection
       */
      clear() {
        this.contents.clear();
      }
      /**
       * Deletes a specific ID from the collection
       * @param id ID to delete
       */
      delete(id) {
        if (!this.contents.has(id)) {
          return false;
        }
        this.emit("remove", this.contents.get(id));
        this.emit("changed", this);
        return this.contents.delete(id);
      }
      /**
       * Gets a certain ID from the collection
       * @param id
       */
      get(id) {
        return this.contents.get(id);
      }
      /**
       * Checks if the collection contains an item with the given ID
       * @param id
       */
      has(id) {
        return this.contents.has(id);
      }
      /**
       * Sets a specific value in the collection
       * @param id
       * @param value
       */
      set(id, value) {
        if (this.contents.has(id)) {
          this.emit("update", value, this.contents.get(id));
          this.emit("changed", this);
        } else {
          this.emit("add", value);
          this.emit("changed", this);
        }
        this.contents.set(id, value);
        return this;
      }
      /**
       * Gets the number of items in the collection
       */
      get size() {
        return this.contents.size;
      }
      /**
       * Iterates through all items in the collection, calling the passed
       *
       * @example
       * const events = await team.events();
       * events.forEach((event, id, collection) => console.log(id, event))
       *
       * @param callback Callback function
       */
      forEach(callback) {
        this.contents.forEach((value, key) => callback(value, key, this));
      }
      /**
       * Returns an iterator with all of the IDs in the collection
       *
       * @example
       * const events = await team.events();
       *
       * for (const id of events.keys()) {
       *  console.log(id);
       * }
       *
       */
      keys() {
        return this.contents.keys();
      }
      /**
       * Returns an iterator with all the items in the collection
       *
       * @example
       * const events = await team.events();
       *
       * for (const event of events.values()) {
       *  console.log(event);
       * }
       *
       */
      values() {
        return this.contents.values();
      }
      /**
       * Returns an entries iterator like [id, value] for the items in the collection
       *
       * @example
       * const events = await team.events();
       *
       * for (const [id, event] of events.entries()) {
       *  console.log(id, event.id)
       * }
       */
      entries() {
        return this.contents.entries();
      }
      // Other utility methods
      /**
       * Returns an array of the values in the collection
       *
       * @example
       * const events = await team.events();
       *
       * events.array().forEach(console.log);
       *
       */
      array() {
        return [...this.contents.values()];
      }
      /**
       * Returns an array of the IDs of the collection
       *
       * @example
       * const events = await team.events();
       *
       * events.idArray().forEach(console.log)
       */
      idArray() {
        return [...this.contents.keys()];
      }
      /**
       * Looks for an item in the collection
       *
       * @example
       * const events = await team.events();
       *
       * const event = events.find((event, id, collection) => event.name.startsWith("Signature Event")));
       *
       * @param predicate Search function
       */
      find(predicate) {
        for (const [id, item] of this.contents) {
          if (predicate(item, id, this)) {
            return item;
          }
        }
        return void 0;
      }
      /**
       * Checks if some of the elements in the collection pass the criterion
       *
       * @example
       * const events = await team.events();
       *
       * const wentToSig = events.some((event, id, collection) => event.name.includes("Signature Event")));
       *
       * if (wentToSig) {
       *  console.log("Went to a signature event");
       * } else {
       *  console.log("Did not go to a signature event")
       * }
       *
       * @param predicate
       */
      some(predicate) {
        for (const [id, item] of this.contents) {
          if (predicate(item, id, this)) {
            return true;
          }
        }
        return false;
      }
      /**
       * Checks if every singe one of the elements in the collection pass the criterion
       *
       * @example
       * const teams = await event.teams();
       *
       * const isLocalOnlyEvent = teams.every(team => team.location.region === event.location.region);
       *
       *
       * @param predicate
       */
      every(predicate) {
        for (const [id, item] of this.contents) {
          if (!predicate(item, id, this)) {
            return false;
          }
        }
        return true;
      }
      /**
       * Group the current contents of the WatchableCollection into a object by the discriminator function.
       *
       * @example
       * const event = robotevents.events.get(sku);
       * const matches = event.matches();
       *
       * const rounds = matches.group(match => match.round);
       * console.log(rounds[Round.RoundOf16]);
       *
       * @param discriminator Function used to sort the objects of the collection into groups
       */
      group(discriminator) {
        var _b;
        let result = /* @__PURE__ */ Object.create(null);
        for (const [id, item] of this.contents) {
          const key = discriminator(item, id, this);
          if (key in result) {
            (_b = result[key]) === null || _b === void 0 ? void 0 : _b.push(item);
          } else {
            result[key] = [item];
          }
          ;
        }
        ;
        return result;
      }
      /**
       * Group the current contents of the WatchableCollection into a map by the discriminator function.
       * Different from WatchableCollection#group, this method returns a Map so the return values can be
       * anything that can be used as a key in a Map.
       *
       * @param discriminator Function used to sort the objects of the collection into groups
       * @returns Map of the grouped items
       */
      groupToMap(discriminator) {
        let result = /* @__PURE__ */ new Map();
        for (const [id, item] of this.contents) {
          const key = discriminator(item, id, this);
          if (result.has(key)) {
            result.set(key, [...result.get(key), item]);
          } else {
            result.set(key, [item]);
          }
          ;
        }
        ;
        return result;
      }
      // Watching
      /**
       * Stops polling the resource for updates
       *
       * @example
       * const events = await team.events();
       *
       * events.watch(10 * 1000); // Check every 10 seconds instead
       *
       * event.on("add", (event) => {
       *  console.log(event);
       * });
       *
       * @param frequency How often to poll for new results, defaults to 30,000 ms
       *
       */
      watch(frequency) {
        this.polling = true;
        if (frequency) {
          this.frequency = frequency;
        }
        this.interval = setInterval(async () => {
          const current = new Map(makeMappable(await this.check(this)));
          for (const [id, value] of current) {
            if (!this.contents.has(id)) {
              this.set(id, value);
              continue;
            }
            const old = this.contents.get(id);
            if (!deepEquals(value, old)) {
              this.set(id, value);
            }
          }
          for (const [id, value] of this.contents) {
            if (current.has(id))
              continue;
            this.delete(id);
          }
        }, this.frequency);
      }
      /**
       * Stops polling the resource for updates
       *
       * @example
       * const events = await team.events();
       *
       * events.watch(10 * 1000); // Check every 10 seconds instead
       *
       * event.on("add", (event) => {
       *  console.log(event);
       * });
       *
       * event.unwatch(); // Stop watching for updates
       *
       */
      unwatch() {
        if (!this.polling || !this.interval) {
          return;
        }
        clearInterval(this.interval);
      }
      /**
       * Creates a new watchable collection from a check function
       * @param check
       */
      static async create(check) {
        const inital = makeMappable(await check());
        return new WatchableCollection(inital, check);
      }
    };
    _a = Symbol.iterator;
    exports.default = WatchableCollection;
    function makeMappable(values) {
      return Object.entries(values).map(([i, value]) => [value.id, value]);
    }
    function deepEquals(a, b) {
      for (const [key, value] of Object.entries(a)) {
        if (!b.hasOwnProperty(key))
          return false;
        const compare = b[key];
        switch (typeof compare) {
          case "object": {
            return deepEquals(value, compare);
          }
          default: {
            if (value !== compare)
              return false;
          }
        }
      }
      return true;
    }
    exports.deepEquals = deepEquals;
  }
});

// node_modules/robotevents/out/endpoints/matches.js
var require_matches = __commonJS({
  "node_modules/robotevents/out/endpoints/matches.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Match = exports.Round = void 0;
    var Round;
    (function(Round2) {
      Round2[Round2["Practice"] = 1] = "Practice";
      Round2[Round2["Qualification"] = 2] = "Qualification";
      Round2[Round2["Quarterfinals"] = 3] = "Quarterfinals";
      Round2[Round2["Semifinals"] = 4] = "Semifinals";
      Round2[Round2["Finals"] = 5] = "Finals";
      Round2[Round2["RoundOf16"] = 6] = "RoundOf16";
      Round2[Round2["TopN"] = 15] = "TopN";
      Round2[Round2["RoundRobin"] = 16] = "RoundRobin";
    })(Round || (exports.Round = Round = {}));
    var Match = class {
      constructor(data) {
        this.id = 0;
        this.event = {
          id: 0,
          name: "",
          code: ""
        };
        this.division = {
          id: 0,
          name: "",
          code: ""
        };
        this.round = Round.Qualification;
        this.instance = 0;
        this.matchnum = 0;
        this.scheduled = "";
        this.started = "";
        this.field = "";
        this.scored = false;
        this.name = "";
        this.alliances = [];
        Object.assign(this, data);
      }
      getData() {
        return {
          id: this.id,
          event: this.event,
          division: this.division,
          round: this.round,
          instance: this.instance,
          matchnum: this.matchnum,
          scheduled: this.scheduled,
          started: this.started,
          field: this.field,
          scored: this.scored,
          name: this.name,
          alliances: this.alliances
        };
      }
      toJSON() {
        return this.getData();
      }
      /**
       * Gets the alliance with the given color
       *
       * @param color Red or Blue
       * @returns The alliance with the given color
       */
      alliance(color) {
        return this.alliances.find((a) => a.color === color);
      }
      /**
       * Gets the outcome of the match
       *
       * @example
       * const team = await robotevents.teams.get("3796B");
       * const matches = await team.matches();
       *
       * for (const match of match) {
       *  const { winner, loser } = match.allianceOutcome();
       *  console.log(winner.color, loser.color)
       * };
       *
       * @returns The winning and losing alliance, or null if the match is unscored or tied
       */
      allianceOutcome() {
        const red = this.alliance("red");
        const blue = this.alliance("blue");
        if (red.score > blue.score) {
          return { winner: red, loser: blue };
        } else if (blue.score > red.score) {
          return { winner: blue, loser: red };
        } else {
          return { winner: null, loser: null };
        }
      }
      /**
       * Gets the outcome of the match for a specific team
       *
       * @param team Team number
       */
      teamOutcome(team) {
        const { winner, loser } = this.allianceOutcome();
        if (!this.scored) {
          return "unscored";
        }
        if (!winner || !loser) {
          return "tie";
        }
        if (winner.teams.find((t) => t.team.code === team)) {
          return "win";
        } else if (loser.teams.find((t) => t.team.code === team)) {
          return "loss";
        } else {
          return "tie";
        }
        ;
      }
      /**
       * Gets all of the teams in the match, excludes non-sitting teams (i.e. teams on the alliance who
       * do not play, very rare in modern competitions)
       * @returns List of all teams in the match
       */
      teams() {
        return this.alliances.flatMap((a) => a.teams.filter((t) => !t.sitting).map((t) => t.team));
      }
      /**
       * Gets a short name for this match based on the round. Short name looks something like
       *
       * ```
       * P 13
       * Q 23
       * R16 1-1
       * QF 1-1
       * SF 2-1
       * F 1-3
       * F 3 // IQ finals matches
       * RR 2-1 // Round Robin
       * ```
       *
       */
      shortName() {
        const id = this.instance + "-" + this.matchnum;
        switch (this.round) {
          case Round.Practice: {
            return "P " + this.matchnum;
          }
          case Round.Qualification: {
            return "Q " + this.matchnum;
          }
          case Round.Quarterfinals: {
            return "QF " + id;
          }
          case Round.Semifinals: {
            return "SF " + id;
          }
          case Round.Finals: {
            return "F " + id;
          }
          case Round.RoundOf16: {
            return "R16 " + id;
          }
          case Round.TopN: {
            return "F " + this.matchnum;
          }
          case Round.RoundRobin: {
            return "RR " + id;
          }
          default: {
            return this.name;
          }
        }
        ;
      }
    };
    exports.Match = Match;
  }
});

// node_modules/robotevents/out/Watchable.js
var require_Watchable = __commonJS({
  "node_modules/robotevents/out/Watchable.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var events_1 = require_events();
    var Watchable = class extends events_1.EventEmitter {
      constructor(check) {
        super();
        this.frequency = 30 * 1e3;
        this.interval = null;
        this.polling = false;
        this.check = check;
      }
      /**
       * Starts watching this resource for updates. Will emit "update" when a key changes.
       *
       * @example
       * const event = await robotevents.events.get(id);
       *
       * event.watch(10 * 1000); // Check every 10 seconds instead
       *
       * event.on("update", (key, current, old) => {
       *  console.log(`${key}: ${old} -> ${current}`);
       * });
       *
       * @param frequency Frequency to check record for update in ms, defaults to 30 000
       */
      watch(frequency) {
        if (frequency) {
          this.frequency = frequency;
        }
        this.polling = true;
        this.interval = setInterval(async () => {
          if (!this.check)
            return;
          const state = await this.check();
          for (const [key, value] of Object.entries(state)) {
            const current = JSON.stringify(this[key]);
            const updated = JSON.stringify(value);
            if (current !== updated) {
              this.emit("update", key, updated, current);
            }
          }
        }, this.frequency);
      }
      /**
       * Stops polling the resource for updates
       *
       * @example
       * const event = await robotevents.events.get(id);
       *
       * event.watch(10 * 1000); // Check every 10 seconds instead
       *
       * event.on("update", (key, current, old) => {
       *  console.log(`${key}: ${old} -> ${current}`);
       * });
       *
       * event.unwatch(); // Stop watching for updates
       *
       */
      unwatch() {
        this.polling = false;
        if (this.interval) {
          clearInterval(this.interval);
        }
      }
    };
    exports.default = Watchable;
  }
});

// node_modules/robotevents/out/endpoints/teams/search.js
var require_search2 = __commonJS({
  "node_modules/robotevents/out/endpoints/teams/search.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.search = void 0;
    var _1 = require_teams();
    var request_1 = __importDefault(require_request());
    async function search(options = {}, maxAge) {
      const response = await (0, request_1.default)(`teams`, options, maxAge);
      return response.map((data) => new _1.Team(data));
    }
    exports.search = search;
  }
});

// node_modules/robotevents/out/endpoints/teams/index.js
var require_teams = __commonJS({
  "node_modules/robotevents/out/endpoints/teams/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.search = exports.get = exports.Team = void 0;
    var Watchable_1 = __importDefault(require_Watchable());
    var request_1 = __importStar(require_request());
    var WatchableCollection_1 = __importDefault(require_WatchableCollection());
    var events_1 = require_events2();
    var matches_1 = require_matches();
    var search_1 = require_search2();
    var main_1 = require_main();
    var Team = class extends Watchable_1.default {
      constructor(data) {
        super(() => (0, request_1.requestSingle)(`teams/${data.id}`, { id: [data.id] }, 0));
        this.id = 0;
        this.number = "";
        this.team_name = "";
        this.robot_name = "";
        this.organization = "";
        this.location = {
          venue: "",
          address_1: "",
          address_2: "",
          city: "",
          region: "",
          postcode: "",
          country: "",
          coordinates: {
            lat: 0,
            lon: 0
          }
        };
        this.registered = false;
        this.program = { id: 0, name: "", code: "" };
        this.grade = "High School";
        for (const [key, value] of Object.entries(data)) {
          this[key] = value;
        }
      }
      /**
       * Gets the RobotEvents listing for the team
       */
      getURL() {
        return `https://www.robotevents.com/teams/${this.program.code}/${this.number}`;
      }
      /**
       * Returns the raw response from RobotEvents
       */
      getData() {
        return {
          id: this.id,
          number: this.number,
          team_name: this.team_name,
          robot_name: this.robot_name,
          organization: this.organization,
          location: this.location,
          registered: this.registered,
          program: this.program,
          grade: this.grade
        };
      }
      /**
       * Converts the team to JSON
       */
      toJSON() {
        return this.getData();
      }
      // Watchable Collections
      /**
       * Gets all events the team has gone to
       * @param options Event Options
       *
       * @example
       * const team = await robotevents.teams.get(number);
       * const events = await team.events({
       *  level: ["State", "National", "Signature"]
       * });
       *
       * for (const event of events) {
       *  console.log(event);
       * }
       *
       */
      events(options = {}) {
        return WatchableCollection_1.default.create(() => (0, request_1.default)(`teams/${this.id}/events`, options, 0).then((response) => response.map((data) => new events_1.Event(data))));
      }
      /**
       * Gets all matches for the team
       * @param options
       *  @param options.event Event IDs
       *  @param options.season Season IDs
       *  @param options.rounds Possible match rounds to search
       *  @param options.instance Possible match instances to search
       *  @param options.matchnum Possible match numbers to search
       *
       * @example
       * const team = await robotevents.teams.get(number);
       * const matches = await team.matches();
       * matches.watch();
       *
       * matches.on("add", match => {
       *  console.log("Match generated")
       * })
       *
       */
      matches(options = {}) {
        return WatchableCollection_1.default.create(() => (0, request_1.default)(`teams/${this.id}/matches`, options, 0).then((matches) => matches.map((match) => new matches_1.Match(match))));
      }
      /**
       * Gets a team's rankings
       * @param options Ranking Options
       *  @param options.event Event IDs
       *  @param options.rank Possible ranks to search for
       *  @param options.season Season IDs
       */
      rankings(options = {}) {
        return WatchableCollection_1.default.create(() => (0, request_1.default)(`teams/${this.id}/rankings`, options, 0));
      }
      /**
       * Gets a team's skills runs
       * @param options Skills Run Options
       *  @param options.event Event IDs to filter
       *  @param options.type Possible skills run types ("driver" or "programming")
       *  @param options.season Season IDs
       */
      skills(options = {}) {
        return WatchableCollection_1.default.create(() => (0, request_1.default)(`teams/${this.id}/skills`, options, 0));
      }
      /**
       * Gets a team's awards
       * @param options Awards Options
       *  @param options.event Event IDs to filter by
       *  @param options.season Season IDs to filter by
       */
      awards(options = {}) {
        return WatchableCollection_1.default.create(() => (0, request_1.default)(`teams/${this.id}/awards`, options, 0));
      }
    };
    exports.Team = Team;
    async function get(numberOrID, abbr, maxAge) {
      let teams = [];
      if (typeof numberOrID == "string") {
        let params = { number: [numberOrID] };
        if (abbr && main_1.programs.get(abbr)) {
          params["program"] = [main_1.programs.get(abbr)];
        }
        teams = await (0, search_1.search)(params, maxAge);
      } else if (typeof numberOrID) {
        teams = await (0, search_1.search)({ id: [numberOrID] }, maxAge);
      }
      if (teams.length < 1) {
        return null;
      }
      return teams[0];
    }
    exports.get = get;
    var search_2 = require_search2();
    Object.defineProperty(exports, "search", { enumerable: true, get: function() {
      return search_2.search;
    } });
  }
});

// node_modules/robotevents/out/endpoints/events/index.js
var require_events2 = __commonJS({
  "node_modules/robotevents/out/endpoints/events/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.search = exports.get = exports.Event = void 0;
    var search_1 = __importDefault(require_search());
    var request_1 = __importStar(require_request());
    var WatchableCollection_1 = __importDefault(require_WatchableCollection());
    var matches_1 = require_matches();
    var teams_1 = require_teams();
    var Watchable_1 = __importDefault(require_Watchable());
    var re_strings = [
      [1, "vex-robotics-competition"],
      [4, "college-competition"],
      [47, "workshops"],
      [40, "create-foundation"],
      [41, "vex-iq-competition"],
      [42, "drones-in-school"],
      [43, "national-robotics-league"],
      [44, "rad"],
      [46, "tsavrc"],
      [47, "tsaviqc"],
      [48, "vaic-hs"],
      [49, "vaic-u"],
      [57, "vex-ai-competition"]
    ];
    var RE_PREFIXES = new Map(re_strings);
    var Event = class extends Watchable_1.default {
      // Load the event
      constructor(data) {
        super(() => (0, request_1.requestSingle)(`events/${data.id}`, {}));
        this.id = 0;
        this.sku = "";
        this.name = "";
        this.start = "";
        this.end = "";
        this.season = {
          id: 0,
          name: "",
          code: null
        };
        this.program = {
          id: 0,
          name: "",
          code: ""
        };
        this.location = {
          venue: "",
          address_1: "",
          address_2: "",
          city: "",
          region: "",
          postcode: "",
          country: "",
          coordinates: {
            lat: 0,
            lon: 0
          }
        };
        this.locations = [];
        this.divisions = [];
        this.level = "Other";
        this.ongoing = false;
        this.awards_finalized = false;
        this.eventType = null;
        for (const [key, value] of Object.entries(data)) {
          this[key] = value;
        }
      }
      /**
       * Gets the associated URL from robotevents for this event
       */
      getURL() {
        const prefix = RE_PREFIXES.get(this.program.id);
        return `https://www.robotevents.com/robot-competitions/${prefix}/${this.sku}.html`;
      }
      getData() {
        return {
          id: this.id,
          sku: this.sku,
          name: this.name,
          start: this.start,
          end: this.end,
          season: this.season,
          program: this.program,
          location: this.location,
          locations: this.locations,
          divisions: this.divisions,
          level: this.level,
          ongoing: this.ongoing,
          awards_finalized: this.awards_finalized,
          eventType: this.eventType
        };
      }
      /**
       * Converts the team to JSON
       */
      toJSON() {
        return this.getData();
      }
      // Watchable Collections
      /**
       * Gets teams at an event
       * @param options Search Options
       *
       * @example Basic Usage
       * const event = await robotevents.events.get(sku);
       * const teams = await event.teams();
       *
       * for (const team of teams) {
       *  console.log(team);
       * }
       *
       * @example Watch for Team Changes
       * teams.watch();
       *
       * teams.on("add", team => {
       *  console.log("Team added", team);
       * })
       *
       * teams.on("remove", team => {
       *  console.log("Team removed", team);
       * });
       *
       */
      teams(options = {}) {
        return WatchableCollection_1.default.create(() => (0, request_1.default)(`events/${this.id}/teams`, options, 0).then((teams) => teams.map((data) => new teams_1.Team(data))));
      }
      /**
       * Gets skills data at an event, as a watchable collection
       * @param options Skills Options
       *
       * @example
       * const event = await robotevents.events.get(sku);
       * const skills = await event.skills({
       *  type: ["driver"]
       * });
       *
       * for (const run of skills) {
       *  console.log(run);
       * }
       *
       * skills.watch();
       * skills.on("add", console.log)
       *
       */
      skills(options = {}) {
        return WatchableCollection_1.default.create(() => (0, request_1.default)(`events/${this.id}/skills`, options, 0));
      }
      /**
       * Gets the awards for the event, returns a watchable collection
       * @param options Award Search Options
       *
       *
       * @example
       * const event = await robotevents.events.get(sku);
       * const awards = await event.matches(1);
       *
       * for (const award of awards) {
       *  console.log(awards)
       * }
       *
       */
      awards(options = {}) {
        return WatchableCollection_1.default.create(() => (0, request_1.default)(`events/${this.id}/awards`, options, 0));
      }
      /**
       * Gets the matches for an event, returns a watchable collection.
       *
       *
       * @example Scored Matches
       * const event = await robotevents.events.get(sku);
       * const matches = await event.matches(1); // Get current state of matches in Division 1
       * matches.watch();
       *
       * matches.on("add", match => console.log("Match Generated", match));
       * matches.on("update", match => console.log("Match Updated", match))
       *
       *
       * @param division Division ID
       * @param options Match Search Options
       */
      matches(division, options = {}) {
        return WatchableCollection_1.default.create(() => (0, request_1.default)(`events/${this.id}/divisions/${division !== null && division !== void 0 ? division : 1}/matches`, options, 0).then((matches) => matches.map((data) => new matches_1.Match(data))));
      }
      /**
       *
       * @param division Division ID
       * @param options Ranking Search Options
       *
       * (VEX IQ only)
       * Gets the finalist rankings for an event
       *
       *
       * @example
       * const event = await robotevents.events.get(sku);
       * const rankings = await event.finalistRankings(1, { rank: [1] });
       * rankings.watch();
       *
       * ranking.on("add", rank => {
       *  console.log("First Place Rank Update", rank);
       * });
       *
       *
       */
      finalistRankings(division, options = {}) {
        return WatchableCollection_1.default.create(() => (0, request_1.default)(`events/${this.id}/divisions/${division !== null && division !== void 0 ? division : 1}/finalistRankings`, options, 0));
      }
      /**
       *
       * @param division Division ID
       * @param options Ranking Search Options
       *
       *
       * @example
       * const event = await robotevents.events.get(sku);
       * const rankings = await event.rankings(1, { rank: [1] });
       * rankings.watch();
       *
       * ranking.on("add", rank => {
       *  console.log("First Place Rank Update", rank);
       * });
       *
       *
       */
      rankings(division, options = {}) {
        return WatchableCollection_1.default.create(() => (0, request_1.default)(`events/${this.id}/divisions/${division !== null && division !== void 0 ? division : 1}/rankings`, options, 0));
      }
    };
    exports.Event = Event;
    async function get(skuOrID, maxAge) {
      let events = [];
      if (typeof skuOrID == "string") {
        events = await (0, search_1.default)({ sku: [skuOrID] }, maxAge);
      } else if (typeof skuOrID) {
        events = await (0, search_1.default)({ id: [skuOrID] }, maxAge);
      }
      if (events.length < 1) {
        return null;
      }
      return new Event(events[0]);
    }
    exports.get = get;
    var search_2 = require_search();
    Object.defineProperty(exports, "search", { enumerable: true, get: function() {
      return __importDefault(search_2).default;
    } });
  }
});

// node_modules/robotevents/out/endpoints/seasons/index.js
var require_seasons = __commonJS({
  "node_modules/robotevents/out/endpoints/seasons/index.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.current = exports.get = exports.years = exports.getEvents = exports.all = exports.fetch = void 0;
    var request_1 = __importStar(require_request());
    var events_1 = require_events2();
    async function fetch(id, maxAge) {
      return (0, request_1.requestSingle)(`seasons/${id}`, {}, maxAge);
    }
    exports.fetch = fetch;
    async function all(maxAge) {
      return (0, request_1.default)("seasons", {}, maxAge);
    }
    exports.all = all;
    async function getEvents(season, options = {}, maxAge) {
      return (0, request_1.default)(`seasons/${season}/events`, options, maxAge).then((response) => response.map((data) => new events_1.Event(data)));
    }
    exports.getEvents = getEvents;
    exports.years = [
      "2024-2025",
      "2023-2024",
      "2022-2023",
      "2021-2022",
      "2020-2021",
      "2019-2020",
      "2018-2019",
      "2017-2018",
      "2016-2017",
      "2015-2016",
      "2014-2015",
      "2013-2014",
      "2012-2013",
      "2011-2012",
      "2010-2011",
      "2009-2010"
    ];
    var seasons = {
      "V5RC": {
        "2024-2025": 190,
        "2023-2024": 181,
        "2022-2023": 173,
        "2021-2022": 154,
        "2020-2021": 139,
        "2019-2020": 130,
        "2018-2019": 125,
        "2017-2018": 119,
        "2016-2017": 115,
        "2015-2016": 110,
        "2014-2015": 102,
        "2013-2014": 92,
        "2012-2013": 85,
        "2011-2012": 73,
        "2010-2011": 7,
        "2009-2010": 1
      },
      "VURC": {
        "2024-2025": 191,
        "2023-2024": 182,
        "2022-2023": 175,
        "2021-2022": 156,
        "2020-2021": 140,
        "2019-2020": 131,
        "2018-2019": 126,
        "2017-2018": 120,
        "2016-2017": 116,
        "2015-2016": 111,
        "2014-2015": 103,
        "2013-2014": 93,
        "2012-2013": 88,
        "2011-2012": 76,
        "2010-2011": 10,
        "2009-2010": 4
      },
      "VAIRC": {
        "2023-2024": 185,
        "2021-2022": 171
      },
      "WORKSHOP": {
        "2023-2024": 118,
        "2015-2016": 113,
        "2014-2015": 107,
        "2013-2014": 98
      },
      "VIQRC": {
        "2024-2025": 189,
        "2023-2024": 180,
        "2022-2023": 174,
        "2021-2022": 155,
        "2020-2021": 138,
        "2019-2020": 129,
        "2018-2019": 124,
        "2017-2018": 121,
        "2016-2017": 114,
        "2015-2016": 109,
        "2014-2015": 101,
        "2013-2014": 96
      },
      "NRL": {
        "2019-2020": 137
      },
      "ADC": {
        "2024-2025": 192,
        "2023-2024": 184,
        "2022-2023": 176,
        "2021-2022": 158,
        "2020-2021": 144,
        "2019-2020": 134
      },
      "TVRC": {
        "2023-2024": 187,
        "2022-2023": 179,
        "2021-2022": 167,
        "2020-2021": 142,
        "2019-2020": 136
      },
      "TVIQRC": {
        "2023-2024": 186,
        "2022-2023": 178,
        "2021-2022": 166,
        "2020-2021": 141,
        "2019-2020": 135
      },
      "VRAD": {},
      "BellAVR": {},
      "FAC": {
        "2023-2024": 188,
        "2022-2023": 177,
        "2021-2022": 165
      }
    };
    function get(program, year) {
      return seasons[program][year];
    }
    exports.get = get;
    function current(program) {
      return seasons[program]["2024-2025"];
    }
    exports.current = current;
  }
});

// node_modules/robotevents/out/v1/index.js
var require_v1 = __commonJS({
  "node_modules/robotevents/out/v1/index.js"(exports) {
    "use strict";
    var __importDefault = exports && exports.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getSkillsLeaderboard = void 0;
    var skills_1 = require_skills();
    Object.defineProperty(exports, "getSkillsLeaderboard", { enumerable: true, get: function() {
      return __importDefault(skills_1).default;
    } });
  }
});

// node_modules/robotevents/out/main.js
var require_main = __commonJS({
  "node_modules/robotevents/out/main.js"(exports) {
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.v1 = exports.request = exports.authentication = exports.ratelimit = exports.teams = exports.events = exports.seasons = exports.programs = void 0;
    exports.programs = __importStar(require_programs());
    exports.seasons = __importStar(require_seasons());
    exports.events = __importStar(require_events2());
    exports.teams = __importStar(require_teams());
    exports.ratelimit = __importStar(require_ratelimit());
    exports.authentication = __importStar(require_authentication());
    exports.request = __importStar(require_request());
    exports.v1 = __importStar(require_v1());
  }
});
export default require_main();
//# sourceMappingURL=robotevents.js.map
