"use strict";
/**
 * Makes a ratelimit respecting request to the robotevents API,
 * supporting caching using keya
 *
 * Every minute, you are allowed to make 1080 requests,
 * this module will automatically queue requests to ensure
 * that rate limiting is obeyed
 **/
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.requestSingle = void 0;
const cross_fetch_1 = __importDefault(require("cross-fetch"));
const ratelimit_1 = require("./ratelimit");
const authentication_1 = require("./authentication");
/**
 * Serializes parameters into a string to be passed to the API
 * @param params RobotEventsRequest
 */
function serialize(params) {
    let body = "";
    for (const [key, value] of Object.entries(params)) {
        switch (typeof value) {
            // Normal passed parameters can be serialized as normal
            case "string":
            case "number":
                body += `${encodeURIComponent(key)}=${encodeURIComponent(value)}&`;
                break;
            // Arrays need to have all of their components added separately
            case "object": {
                for (const v of value) {
                    body += `${encodeURIComponent(key)}[]=${encodeURIComponent(v)}&`;
                }
                break;
            }
        }
    }
    // Remove the last ampersand and return
    return body.slice(0, body.length - 1);
}
async function doRequest(url) {
    // Wait for the ratelimit to be clear (resolves immediately if ok)
    await (0, ratelimit_1.ready)();
    let headers = {};
    if (authentication_1.BEARER) {
        headers["Authorization"] = `Bearer ${authentication_1.BEARER}`;
    }
    // Make the initial request
    const response = await (0, cross_fetch_1.default)(url.href, {
        headers,
    });
    // Set the new ratelimit
    if (response.headers.has("x-ratelimit-remaining")) {
        (0, ratelimit_1.updateCurrent)(parseInt(response.headers.get("x-ratelimit-remaining")));
    }
    // If the response errored reject accordingly
    if (!response.ok) {
        return Promise.reject(await response.text());
    }
    return response.json();
}
async function request(endpoint, params, maxAge = Infinity) {
    // Join the URL together
    const url = new URL(endpoint, "https://www.robotevents.com/api/v2/");
    // Add the (custom serialized) search params to support the custom array behavior of the API
    url.search = serialize({ per_page: 250, ...params });
    // Now get the initial request
    let page = await doRequest(url);
    let data = page.data;
    // Paginate if needed
    while (page.meta.current_page < page.meta.last_page) {
        url.searchParams.set("page", (page.meta.current_page + 1).toString());
        page = await doRequest(url);
        data.push(...page.data);
    }
    // Delete pagination keys
    url.searchParams.delete("page");
    return data;
}
exports.default = request;
async function requestSingle(endpoint, params, maxAge = Infinity) {
    // Join the URL together
    const url = new URL(endpoint, "https://www.robotevents.com/api/v2/");
    // Add the (custom serialized) search params to support the custom array behavior of the API
    url.search = serialize(params);
    return doRequest(url);
}
exports.requestSingle = requestSingle;
//# sourceMappingURL=request.js.map