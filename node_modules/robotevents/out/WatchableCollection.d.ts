/// <reference types="node" />
/**
 * Creates a watchable collection,
 * basically an array of contents that can be passed .watch()
 * to watch for updates
 *
 * const teams = await event.teams();
 * teams.watch();
 *
 * teams.on("changed", teams => {
 *  const regions = teams.group(team => team.location.region);
 * });
 *
 */
import { EventEmitter } from "events";
interface WatchableCollectionEvents<T extends {
    id: I;
}, I> {
    add: (item: T) => void;
    remove: (item: T) => void;
    update: (current: T, old: T) => void;
    changed: (self: WatchableCollection<T, I>) => void;
}
export default interface WatchableCollection<T extends {
    id: I;
}, I> {
    on<U extends keyof WatchableCollectionEvents<T, I>>(event: U, listener: WatchableCollectionEvents<T, I>[U]): this;
    once<U extends keyof WatchableCollectionEvents<T, I>>(event: U, listener: WatchableCollectionEvents<T, I>[U]): this;
    off<U extends keyof WatchableCollectionEvents<T, I>>(event: U, listener: WatchableCollectionEvents<T, I>[U]): this;
}
type CheckFunction<T extends {
    id: I;
}, I> = (self: WatchableCollection<T, I>) => Promise<T[]> | T[];
export default class WatchableCollection<T extends {
    id: I;
}, I = number> extends EventEmitter {
    private contents;
    private check;
    private interval;
    private frequency;
    polling: boolean;
    constructor(initial: [I, T][], check: CheckFunction<T, I>);
    /**
     * Empties the contents of the collection
     */
    clear(): void;
    /**
     * Deletes a specific ID from the collection
     * @param id ID to delete
     */
    delete(id: I): boolean;
    /**
     * Gets a certain ID from the collection
     * @param id
     */
    get(id: I): T | undefined;
    /**
     * Checks if the collection contains an item with the given ID
     * @param id
     */
    has(id: I): boolean;
    /**
     * Sets a specific value in the collection
     * @param id
     * @param value
     */
    set(id: I, value: T): this;
    /**
     * Gets the number of items in the collection
     */
    get size(): number;
    /**
     * Iterates through all items in the collection, calling the passed
     *
     * @example
     * const events = await team.events();
     * events.forEach((event, id, collection) => console.log(id, event))
     *
     * @param callback Callback function
     */
    forEach(callback: (value: T, key: I, collection: WatchableCollection<T, I>) => void): void;
    /**
     * Returns an iterator with all of the IDs in the collection
     *
     * @example
     * const events = await team.events();
     *
     * for (const id of events.keys()) {
     *  console.log(id);
     * }
     *
     */
    keys(): IterableIterator<I>;
    /**
     * Returns an iterator with all the items in the collection
     *
     * @example
     * const events = await team.events();
     *
     * for (const event of events.values()) {
     *  console.log(event);
     * }
     *
     */
    values(): IterableIterator<T>;
    /**
     * Returns an entries iterator like [id, value] for the items in the collection
     *
     * @example
     * const events = await team.events();
     *
     * for (const [id, event] of events.entries()) {
     *  console.log(id, event.id)
     * }
     */
    entries(): IterableIterator<[I, T]>;
    /**
     * Default iterator for the collection. Same as WatchableCollection#values
     *
     * @example
     *
     * const events = await team.events();
     * for (const event of events) {
     *  console.log(event);
     * }
     */
    [Symbol.iterator]: () => IterableIterator<T>;
    /**
     * Returns an array of the values in the collection
     *
     * @example
     * const events = await team.events();
     *
     * events.array().forEach(console.log);
     *
     */
    array(): T[];
    /**
     * Returns an array of the IDs of the collection
     *
     * @example
     * const events = await team.events();
     *
     * events.idArray().forEach(console.log)
     */
    idArray(): I[];
    /**
     * Looks for an item in the collection
     *
     * @example
     * const events = await team.events();
     *
     * const event = events.find((event, id, collection) => event.name.startsWith("Signature Event")));
     *
     * @param predicate Search function
     */
    find(predicate: (item: T, id: I, collection: WatchableCollection<T, I>) => boolean): T | undefined;
    /**
     * Checks if some of the elements in the collection pass the criterion
     *
     * @example
     * const events = await team.events();
     *
     * const wentToSig = events.some((event, id, collection) => event.name.includes("Signature Event")));
     *
     * if (wentToSig) {
     *  console.log("Went to a signature event");
     * } else {
     *  console.log("Did not go to a signature event")
     * }
     *
     * @param predicate
     */
    some(predicate: (item: T, id: I, collection: WatchableCollection<T, I>) => boolean): boolean;
    /**
     * Checks if every singe one of the elements in the collection pass the criterion
     *
     * @example
     * const teams = await event.teams();
     *
     * const isLocalOnlyEvent = teams.every(team => team.location.region === event.location.region);
     *
     *
     * @param predicate
     */
    every(predicate: (item: T, id: I, collection: WatchableCollection<T, I>) => boolean): boolean;
    /**
     * Group the current contents of the WatchableCollection into a object by the discriminator function.
     *
     * @example
     * const event = robotevents.events.get(sku);
     * const matches = event.matches();
     *
     * const rounds = matches.group(match => match.round);
     * console.log(rounds[Round.RoundOf16]);
     *
     * @param discriminator Function used to sort the objects of the collection into groups
     */
    group<K extends string | number | symbol>(discriminator: (item: T, id: I, collection: WatchableCollection<T, I>) => K): Partial<Record<K, T[]>>;
    /**
     * Group the current contents of the WatchableCollection into a map by the discriminator function.
     * Different from WatchableCollection#group, this method returns a Map so the return values can be
     * anything that can be used as a key in a Map.
     *
     * @param discriminator Function used to sort the objects of the collection into groups
     * @returns Map of the grouped items
     */
    groupToMap<K>(discriminator: (item: T, id: I, collection: WatchableCollection<T, I>) => K): Map<K, T[]>;
    /**
     * Stops polling the resource for updates
     *
     * @example
     * const events = await team.events();
     *
     * events.watch(10 * 1000); // Check every 10 seconds instead
     *
     * event.on("add", (event) => {
     *  console.log(event);
     * });
     *
     * @param frequency How often to poll for new results, defaults to 30,000 ms
     *
     */
    watch(frequency?: number): void;
    /**
     * Stops polling the resource for updates
     *
     * @example
     * const events = await team.events();
     *
     * events.watch(10 * 1000); // Check every 10 seconds instead
     *
     * event.on("add", (event) => {
     *  console.log(event);
     * });
     *
     * event.unwatch(); // Stop watching for updates
     *
     */
    unwatch(): void;
    /**
     * Creates a new watchable collection from a check function
     * @param check
     */
    static create<T extends {
        id: number;
    }>(check: () => Promise<T[]> | T[]): Promise<WatchableCollection<T, number>>;
}
export declare function deepEquals(a: object, b: object): boolean;
export {};
