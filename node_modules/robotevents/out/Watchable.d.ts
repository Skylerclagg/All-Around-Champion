/**
 * Makes a class Watchable
 *
 * For example, allows you to monitor events for updates
 *
 */
/// <reference types="node" />
/// <reference types="node" />
import { EventEmitter } from "events";
export type Get<T> = () => Promise<T> | T;
export type EntriesIterable<T> = Record<string | number | symbol, T> | ArrayLike<T>;
interface WatchableEvents<T, I extends keyof T = keyof T> {
    update: (key: I, current: T[I], old: T[I]) => void;
}
interface Watchable<T> {
    on<U extends keyof WatchableEvents<T>>(event: U, listener: WatchableEvents<T>[U]): this;
    once<U extends keyof WatchableEvents<T>>(event: U, listener: WatchableEvents<T>[U]): this;
    off<U extends keyof WatchableEvents<T>>(event: U, listener: WatchableEvents<T>[U]): this;
}
declare abstract class Watchable<T> extends EventEmitter {
    check: Get<T>;
    frequency: number;
    interval: NodeJS.Timeout | null;
    polling: boolean;
    constructor(check: Get<T>);
    /**
     * Starts watching this resource for updates. Will emit "update" when a key changes.
     *
     * @example
     * const event = await robotevents.events.get(id);
     *
     * event.watch(10 * 1000); // Check every 10 seconds instead
     *
     * event.on("update", (key, current, old) => {
     *  console.log(`${key}: ${old} -> ${current}`);
     * });
     *
     * @param frequency Frequency to check record for update in ms, defaults to 30 000
     */
    watch(frequency?: number): void;
    /**
     * Stops polling the resource for updates
     *
     * @example
     * const event = await robotevents.events.get(id);
     *
     * event.watch(10 * 1000); // Check every 10 seconds instead
     *
     * event.on("update", (key, current, old) => {
     *  console.log(`${key}: ${old} -> ${current}`);
     * });
     *
     * event.unwatch(); // Stop watching for updates
     *
     */
    unwatch(): void;
}
export default Watchable;
