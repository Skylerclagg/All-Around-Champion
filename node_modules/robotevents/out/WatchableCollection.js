"use strict";
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.deepEquals = void 0;
/**
 * Creates a watchable collection,
 * basically an array of contents that can be passed .watch()
 * to watch for updates
 *
 * const teams = await event.teams();
 * teams.watch();
 *
 * teams.on("changed", teams => {
 *  const regions = teams.group(team => team.location.region);
 * });
 *
 */
const events_1 = require("events");
class WatchableCollection extends events_1.EventEmitter {
    constructor(initial, check) {
        super();
        // Holds all of contents of the collection
        this.contents = new Map();
        this.interval = null;
        this.frequency = 30 * 1000;
        this.polling = false;
        /**
         * Default iterator for the collection. Same as WatchableCollection#values
         *
         * @example
         *
         * const events = await team.events();
         * for (const event of events) {
         *  console.log(event);
         * }
         */
        this[_a] = this.values;
        this.contents = new Map(initial);
        this.check = check;
    }
    // Map methods
    /**
     * Empties the contents of the collection
     */
    clear() {
        this.contents.clear();
    }
    /**
     * Deletes a specific ID from the collection
     * @param id ID to delete
     */
    delete(id) {
        if (!this.contents.has(id)) {
            return false;
        }
        this.emit("remove", this.contents.get(id));
        this.emit("changed", this);
        return this.contents.delete(id);
    }
    /**
     * Gets a certain ID from the collection
     * @param id
     */
    get(id) {
        return this.contents.get(id);
    }
    /**
     * Checks if the collection contains an item with the given ID
     * @param id
     */
    has(id) {
        return this.contents.has(id);
    }
    /**
     * Sets a specific value in the collection
     * @param id
     * @param value
     */
    set(id, value) {
        if (this.contents.has(id)) {
            this.emit("update", value, this.contents.get(id));
            this.emit("changed", this);
        }
        else {
            this.emit("add", value);
            this.emit("changed", this);
        }
        this.contents.set(id, value);
        return this;
    }
    /**
     * Gets the number of items in the collection
     */
    get size() {
        return this.contents.size;
    }
    /**
     * Iterates through all items in the collection, calling the passed
     *
     * @example
     * const events = await team.events();
     * events.forEach((event, id, collection) => console.log(id, event))
     *
     * @param callback Callback function
     */
    forEach(callback) {
        this.contents.forEach((value, key) => callback(value, key, this));
    }
    /**
     * Returns an iterator with all of the IDs in the collection
     *
     * @example
     * const events = await team.events();
     *
     * for (const id of events.keys()) {
     *  console.log(id);
     * }
     *
     */
    keys() {
        return this.contents.keys();
    }
    /**
     * Returns an iterator with all the items in the collection
     *
     * @example
     * const events = await team.events();
     *
     * for (const event of events.values()) {
     *  console.log(event);
     * }
     *
     */
    values() {
        return this.contents.values();
    }
    /**
     * Returns an entries iterator like [id, value] for the items in the collection
     *
     * @example
     * const events = await team.events();
     *
     * for (const [id, event] of events.entries()) {
     *  console.log(id, event.id)
     * }
     */
    entries() {
        return this.contents.entries();
    }
    // Other utility methods
    /**
     * Returns an array of the values in the collection
     *
     * @example
     * const events = await team.events();
     *
     * events.array().forEach(console.log);
     *
     */
    array() {
        return [...this.contents.values()];
    }
    /**
     * Returns an array of the IDs of the collection
     *
     * @example
     * const events = await team.events();
     *
     * events.idArray().forEach(console.log)
     */
    idArray() {
        return [...this.contents.keys()];
    }
    /**
     * Looks for an item in the collection
     *
     * @example
     * const events = await team.events();
     *
     * const event = events.find((event, id, collection) => event.name.startsWith("Signature Event")));
     *
     * @param predicate Search function
     */
    find(predicate) {
        for (const [id, item] of this.contents) {
            if (predicate(item, id, this)) {
                return item;
            }
        }
        return undefined;
    }
    /**
     * Checks if some of the elements in the collection pass the criterion
     *
     * @example
     * const events = await team.events();
     *
     * const wentToSig = events.some((event, id, collection) => event.name.includes("Signature Event")));
     *
     * if (wentToSig) {
     *  console.log("Went to a signature event");
     * } else {
     *  console.log("Did not go to a signature event")
     * }
     *
     * @param predicate
     */
    some(predicate) {
        for (const [id, item] of this.contents) {
            if (predicate(item, id, this)) {
                return true;
            }
        }
        return false;
    }
    /**
     * Checks if every singe one of the elements in the collection pass the criterion
     *
     * @example
     * const teams = await event.teams();
     *
     * const isLocalOnlyEvent = teams.every(team => team.location.region === event.location.region);
     *
     *
     * @param predicate
     */
    every(predicate) {
        for (const [id, item] of this.contents) {
            if (!predicate(item, id, this)) {
                return false;
            }
        }
        return true;
    }
    /**
     * Group the current contents of the WatchableCollection into a object by the discriminator function.
     *
     * @example
     * const event = robotevents.events.get(sku);
     * const matches = event.matches();
     *
     * const rounds = matches.group(match => match.round);
     * console.log(rounds[Round.RoundOf16]);
     *
     * @param discriminator Function used to sort the objects of the collection into groups
     */
    group(discriminator) {
        var _b;
        let result = Object.create(null);
        for (const [id, item] of this.contents) {
            const key = discriminator(item, id, this);
            if (key in result) {
                (_b = result[key]) === null || _b === void 0 ? void 0 : _b.push(item);
            }
            else {
                result[key] = [item];
            }
            ;
        }
        ;
        return result;
    }
    ;
    /**
     * Group the current contents of the WatchableCollection into a map by the discriminator function.
     * Different from WatchableCollection#group, this method returns a Map so the return values can be
     * anything that can be used as a key in a Map.
     *
     * @param discriminator Function used to sort the objects of the collection into groups
     * @returns Map of the grouped items
     */
    groupToMap(discriminator) {
        let result = new Map();
        for (const [id, item] of this.contents) {
            const key = discriminator(item, id, this);
            if (result.has(key)) {
                result.set(key, [...result.get(key), item]);
            }
            else {
                result.set(key, [item]);
            }
            ;
        }
        ;
        return result;
    }
    // Watching
    /**
     * Stops polling the resource for updates
     *
     * @example
     * const events = await team.events();
     *
     * events.watch(10 * 1000); // Check every 10 seconds instead
     *
     * event.on("add", (event) => {
     *  console.log(event);
     * });
     *
     * @param frequency How often to poll for new results, defaults to 30,000 ms
     *
     */
    watch(frequency) {
        this.polling = true;
        if (frequency) {
            this.frequency = frequency;
        }
        this.interval = setInterval(async () => {
            const current = new Map(makeMappable(await this.check(this)));
            // Check for new and updated items
            for (const [id, value] of current) {
                if (!this.contents.has(id)) {
                    this.set(id, value);
                    continue;
                }
                const old = this.contents.get(id);
                if (!deepEquals(value, old)) {
                    this.set(id, value);
                }
            }
            // Check for removed values
            for (const [id, value] of this.contents) {
                if (current.has(id))
                    continue;
                this.delete(id);
            }
        }, this.frequency);
    }
    /**
     * Stops polling the resource for updates
     *
     * @example
     * const events = await team.events();
     *
     * events.watch(10 * 1000); // Check every 10 seconds instead
     *
     * event.on("add", (event) => {
     *  console.log(event);
     * });
     *
     * event.unwatch(); // Stop watching for updates
     *
     */
    unwatch() {
        if (!this.polling || !this.interval) {
            return;
        }
        clearInterval(this.interval);
    }
    /**
     * Creates a new watchable collection from a check function
     * @param check
     */
    static async create(check) {
        const inital = makeMappable(await check());
        return new WatchableCollection(inital, check);
    }
}
_a = Symbol.iterator;
exports.default = WatchableCollection;
function makeMappable(values) {
    return Object.entries(values).map(([i, value]) => [value.id, value]);
}
function deepEquals(a, b) {
    for (const [key, value] of Object.entries(a)) {
        if (!b.hasOwnProperty(key))
            return false;
        const compare = b[key];
        switch (typeof compare) {
            case "object": {
                return deepEquals(value, compare);
            }
            default: {
                if (value !== compare)
                    return false;
            }
        }
    }
    return true;
}
exports.deepEquals = deepEquals;
//# sourceMappingURL=WatchableCollection.js.map