"use strict";
/**
 * Makes a class Watchable
 *
 * For example, allows you to monitor events for updates
 *
 */
Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = require("events");
class Watchable extends events_1.EventEmitter {
    constructor(check) {
        super();
        this.frequency = 30 * 1000;
        this.interval = null;
        this.polling = false;
        this.check = check;
    }
    /**
     * Starts watching this resource for updates. Will emit "update" when a key changes.
     *
     * @example
     * const event = await robotevents.events.get(id);
     *
     * event.watch(10 * 1000); // Check every 10 seconds instead
     *
     * event.on("update", (key, current, old) => {
     *  console.log(`${key}: ${old} -> ${current}`);
     * });
     *
     * @param frequency Frequency to check record for update in ms, defaults to 30 000
     */
    watch(frequency) {
        if (frequency) {
            this.frequency = frequency;
        }
        this.polling = true;
        this.interval = setInterval(async () => {
            if (!this.check)
                return;
            const state = await this.check();
            for (const [key, value] of Object.entries(state)) {
                // @ts-ignore
                const current = JSON.stringify(this[key]);
                const updated = JSON.stringify(value);
                if (current !== updated) {
                    this.emit("update", key, updated, current);
                }
            }
        }, this.frequency);
    }
    /**
     * Stops polling the resource for updates
     *
     * @example
     * const event = await robotevents.events.get(id);
     *
     * event.watch(10 * 1000); // Check every 10 seconds instead
     *
     * event.on("update", (key, current, old) => {
     *  console.log(`${key}: ${old} -> ${current}`);
     * });
     *
     * event.unwatch(); // Stop watching for updates
     *
     */
    unwatch() {
        this.polling = false;
        if (this.interval) {
            clearInterval(this.interval);
        }
    }
}
exports.default = Watchable;
//# sourceMappingURL=Watchable.js.map